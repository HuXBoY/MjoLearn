---
title: ساختمان داده - جلسه اول
---
# ساختمان داده - جلسه اول

## ساختمان داده چیست؟

ساختمان داده‌ها روشی برای سازمان‌دهی و ذخیره‌سازی داده‌ها در کامپیوتر است تا بتوان آن‌ها را به‌صورت کارآمد پردازش، ذخیره، و بازیابی کرد.

به عبارتی، ساختمان داده‌ها مثل قفسه‌های یک کتابخانه هستند که کتاب‌ها (داده‌ها) را به شکلی منظم نگه می‌دارند تا دسترسی و استفاده از آن‌ها راحت‌تر باشد.


## چرا مهم است؟

 انتخاب ساختمان داده مناسب می‌تواند سرعت اجرای برنامه، مصرف حافظه، و خوانایی کد را بهبود دهد.


## انواع ساختمان داده‌ها

ساختمان داده‌ها به سه دسته اصلی تقسیم می‌شوند:
[ایستا](#static)، [نیمه ایستا](#semi-static) و [پویا](#dynamic)

همچنین میتونید [نمودار انواع ساختمان داده ها](#_4) رو ببینید

- ### ایستا (Static)

    داده‌ها اندازه ثابت دارند و در زمان اجرا تغییر نمی‌کنند، دو دسته ی: [اولیه](#primitive) و [غیر اولیه](#non-primitive)

    - #### اولیه (Primitive)

        دارای دو دسته ی: [اعداد صحیح](#integer) و [اعداد اعشاری](#float)

        - ##### اعداد صحیح (Integer)
            مثل 5, -10
        - ##### اعداد اعشاری (Float)
            مثل 3.14, 0.001

    - #### غیر اولیه (Non-Primitive)

        دارای دو دسته ی: [آرایه ها](#arrays) و [رکورد ها](#recordsstructs)

        - ##### آرایه‌ها (Arrays)
            مجموعه‌ای از داده‌ها با اندیس و مقدار. مثال: a[0] = 10
        
        - ##### رکوردها (Records/Structs)
            ترکیبی از داده‌های مختلف (مثل نام و سن یک دانشجو).

- ### نیمه‌ ایستا (Semi-Static)

    اندازه تا حدی ثابت است، اما می‌توان داده‌ها را اضافه یا حذف کرد.

    دارای دو دسته ی: [صف](#queue) و [پشته](#stack)

    - #### صف (Queue)
        مثل صف نانوایی؛ داده‌ها به ترتیب ورود (FIFO) پردازش می‌شوند.
    
    - #### پشته (Stack)
        مثل بشقاب‌های روی هم؛ داده‌ها به ترتیب آخرین ورود (LIFO) حذف می‌شوند.

- ### پویا (Dynamic)

    اندازه می‌تواند در زمان اجرا تغییر کند.

    دارای دو دسته ی: [خطی](#linear) و [غیر خطی](#non-linear)

    - #### خطی (Linear)

        دسته ی: [لیست پیوندی](#linked-list)

        - ##### لیست پیوندی (Linked List)
            گره‌هایی که با اشاره‌گر به هم متصل‌اند. مثال: لیست اعداد [1 -> 3 -> 5].

    - #### غیرخطی (Non-Linear)

        دارای دو دسته ی: [گراف](#graph) و [درخت](#tree)

        - ##### گراف (Graph)
            مجموعه‌ای از گره‌ها و یال‌ها برای نمایش روابط پیچیده.

            که مثالش رو یکم پایینتر توی [نمودار انواع ساختمان داده ها](#_5) میتونید ببینید
        
        - ##### درخت (Tree)
            ساختار سلسله‌مراتبی مثل شجره‌نامه خانوادگی.

            درخت خودش یک نوع گراف هست و باز هم میشه به [نمودار انواع ساختمان داده ها](#_5) اشاره کرد


## نمودار انواع ساختمان داده

``` mermaid
graph RL

    main[انواع ساختمان داده] --> static[ایستا]
        static[ایستا] --> primitive[اولیه]
            primitive[اولیه] --> float[اعداد اعشاری]
            primitive[اولیه] --> integer[اعداد صحیح]
        static[ایستا] --> non-primitive[غیر اولیه]
            non-primitive[غیر اولیه] --> arrays[آرایه ها]
            non-primitive[غیر اولیه] --> records[رکورد ها]
    main[انواع ساختمان داده] --> semi-static[نیمه ایستا]
        semi-static[نیمه ایستا] --> queue[صف]
        semi-static[نیمه ایستا] --> stack[پشته]
    main[انواع ساختمان داده] --> dynamic[پویا]
        dynamic[پویا] --> linear[خطی]
            linear[خطی] --> list[لیست پیوندی]
        dynamic[پویا] --> nonlinear[غیر خطی]
            nonlinear[غیر خطی] --> gra-phب[گراف]
            nonlinear[غیر خطی] --> tree[درخت]
```


## آرایه‌ها: مفاهیم پایه و محاسبه آدرس

آرایه‌ها مجموعه‌ای از داده‌ها با اندیس (Index) و مقدار (Value) هستند که در حافظه به‌صورت متوالی ذخیره می‌شوند.

### محاسبه آدرس در آرایه یک‌بعدی
آدرس هر عنصر آرایه با فرمول زیر محاسبه می‌شود:

```
آدرس a[i] = آدرس پایه (Base Address) + (i(اندیس) × اندازه نوع داده)
```

$$
Address \space a[i] = Base \space Address + ( \space i × Bytes \space of \space data \space )
$$

آدرس پایه: آدرس اولین عنصر آرایه ( a[0] ).

اندازه نوع داده: برای int معمولاً 2 بایت، برای float معمولاً 4 بایت ( استاد این اعداد رو در نظر گرفتن ).

!!! tip "بیشتر بدانیم"
    معمولا اندازه نوع داده در همه سیستم ها یکی نیست و اندازه int ها 4 بایت و float ها رو 4 یا 8 بایت در نظر میگیرن

    اما چون ما نمره میخوایم و اینا برامون مهم نیست همون 2 و 4 رو در نظر میگیریم و استاد هم به همینا نمره میدن

!!! example "مثال"
    ```
    Base(a) = 100
    int a[5]

    a[0] = ?
    a[2] = ?
    a[4] = ?
    ```

    ??? success "پاسخ"
        ```
        a[0] = 100
        اولین اندیس همون آدرس پایه رو داره

        a[2] = 100 + 2 * 2 = 104

        a[4] = 100 + 4 * 2 = 108
        ```

!!! Example "مثال"
    ```
    Base(b) = 200
    float b[8]

    b[0] = ?
    b[3] = ?
    b[6] = ?
    b[8] = ?

    مقدار فضای کل مورد نیاز برای ذخیره سازی این آرایه ؟
    ```

    ??? success "پاسخ"
        ```
        b[0] = 200 همون آدرس پایه

        b[3] = 200 + 3 * 4 = 212

        b[6] = 200 + 6 * 4 = 224

        b[8] = اندیس 8 خارج از آرایه است (آرایه از 0 تا 7 است). پس وجود ندارد.

        مقدار کل فضای مورد نیاز برای ذخیره سازی این آرایه همچنین
        8 * 4 = 32 Byte
        ```


## ماتریس ( آرایه دوبعدی )

ماتریس‌ها آرایه‌هایی با دو اندیس (سطر و ستون) هستند، مثل x[2][3] که 2 سطر و 3 ستون دارد.

### روش های ذخیره ماتریس

ذخیره سطری و ذخیره ی ستونی

- #### ذخیره سطری

    عناصر به ترتیب سطر ها ذخیره می‌شوند (چپ به راست، سپس سطر بعدی)

- #### ذخیره ستونی

    عناصر به ترتیب ستون ها ذخیره می‌شوند (بالا به پایین، سپس ستون بعدی)

!!! example "مثال"
    ```
    int x[2][3]
    Base x = 100
    ```

    ( توی سایت تمام ماتریس ها به اینشکل نشون داده میشن )

    $$
    \begin{bmatrix}
    x_{0,0} & x_{0,1} & x_{0,2} \\
    x_{1,0} & x_{1,1} & x_{1,2}
    \end{bmatrix}
    $$

    عدد اول در ماتریس تعداد سطر و عدد دوم تعداد ستون هست

    اما در عناصر و شماره گذاری آنها اندیس ها مانند آرایه از 0 شروع میشوند

    $$ x_{0, 1} \space\space | \space\space x[0][1]$$

    در اینجا این عنصر در سطر 0 ( اول ) و ستون 1 ( دوم ) قرار دارد.

    به طور مثال در این ماتریس ذخیره ستونی و ذخیره سطری به این شکل انجام میشن:

    سطری:

    $$ x[0][0], x[0][1], x[0][2], x[1][0], x[1][1], x[1][2] $$

    ستونی:

    $$ x[0][0], x[1][0], x[0][1], x[1][1], x[0][2], x[1][2] $$

    برای به دست آوردن آدرس یک عنصر در ماتریس باید دقت کنید که ذخیره سطری در نظر گرفته شده یا ذخیره ستونی.

    ```
    Base x = 100 

    Address x[0][1] = ?
    Address x[1][1] = ?
    ```

    در ذخیره سطری:

    ```
    Address x[0][1] = 100 + 1 * 2 = 102
    Address x[1][1] = 100 + 4 * 2 = 108
    ```

    در ذخیره ستونی:

    ```
    Address x[0][1] = 100 + 2 * 2 = 104
    Address x[1][1] = 100 + 3 * 2 = 106
    ```

    همونطور که میبینید جواب ها کاملا در ذخیره ستونی یا سطری با هم متفاوت هستند.

    در سوالات اینکه کدام روش ذخیره سازی انجام شده رو بهمون میگن.

## اسپارس ( ماتریس خلوت )

اسپارس یا ماتریس خلوت ماتریسی است که تعداد کمی از اندیس های آن دارای مقدار هستند

و با روش های دیگر میتوان ساده تر و با استفاده از منابع کمتر آن اطلاعات یا مقادیر را ذخیره کرد.

به طور مثال به ماتریس زیر نگاه کنید

$$
\begin{bmatrix} 
0 & 0 & 0 & 0 \\
5 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 \\
0 & 7 & 0 & 0 \\
0 & 0 & 0 & 0
\end{bmatrix}
$$

در این ماتریس فقط دو اندیس دارای مقادیر داریم اندیس [0][1] با مقدار 5 و اندیس [1][3] با مقدار 7

اما در حافظه از فضای بسیار بیشتری استفاده میکنیم ( 4×5×2 Bytes )

به این ماتریس ها اسپارس یا ماتریس خلوت میگیم و برای حل مشکلاتی که گفته شد یک راه حل داریم:

میایم و یه ماتریس جدید میسازیم که بهتر این اطلاعات رو برامون ذخیره سازی کنه:

چطور این ماتریس جدید رو میسازیم ؟

ماتریس جدید به این شکل تشکیل میشه:

``` mermaid
graph RL
a[سطر اول]
b[ستون اول: تعداد سطر های ماتریس اصلی]
c[ستون دوم: تعداد ستون های ماتریس اصلی]
d[ستون سوم: تعداد مقادیر غیر صفر]
e[باقی سطر ها]
f[ستون اول: شماره سطر]
g[ستون دوم: شماره ستون]
h[ستون سوم: مقدار غیر صفر]
a --> b
a --> c
a --> d
e --> f
e --> g
e --> h
```

اگه نفهمیدین چی شد نگران نباشید تنها نیستید.

بیاید تا با یه مثال روشنش کنیم:

همین ماتریس بالا رو میخوایم به ماتریس جدیدمون تبدیلش کنیم:
اول میایم و سطر اول رو مینویسیم

$$
\begin{bmatrix} 
5 & 4 & 2
\end{bmatrix}
$$

تعداد سطر ها، ستون ها و مقادیر غیر صفر رو توی سطر اول مینویسیم. بعد از اون میریم برای سطر های بعدی و برای هرکدوم از مقادیر غیر صفر سطرش رو کامل میکنیم:

$$
\begin{bmatrix} 
5 & 4 & 2 \\
1 & 0 & 5 \\
3 & 1 & 7
\end{bmatrix}
$$

همین!

حالا اگه مقدار فضای اشغالی توسط این ماتریس رو با ماتریس قبلی مقایسه کنیم میبینید که چقدر بهینه تر هست.

$$
ماتریس\spaceقبلی \\
5 * 4 * 2 = 40 Bytes \\
ماتریس\spaceجدید \\
3 * 3 * 2 = 18 Bytes
$$

## نحوه ذخیره سازی چند جمله ای ها

برای مثال میخوایم این چند جمله ای رو ذخیره کنیم.

$$ 3x^3 + 5x^2 + 1 $$

میایم و از راست به چپ و از 0 تا بیشترین توان x یک جدول میکشیم.
که در این مورد بیشترین توان 3 هست.

$$
\stackrel{3}{\boxed{}} \stackrel{2}{\boxed{}} \stackrel{1}{\boxed{}} \stackrel{0}{\boxed{}}
$$

حالا ضریب x برای هر توان رو توی جدول وارد میکنیم.
مثلا ضریب x به توان 3 عدد 3 هست،
یا ضریب x به توان 2 عدد 5 هست.

$$
\stackrel{3}{\boxed{3}} \stackrel{2}{\boxed{5}} \stackrel{1}{\boxed{0}} \stackrel{0}{\boxed{1}}
$$

مبیبینید که چقدر راحت تونستیم ذخیره اش کنیم :material-emoticon-happy:

اما در مورد یه همچین چند جمله ای چطور ؟

$$ 7x^{258} + 4x^{193} + 2x^3 + 15 $$

$$ \stackrel{258}{\boxed{7}} \stackrel{...}{\boxed{0}} \stackrel{...}{\boxed{0}} \stackrel{193}{\boxed{4}} \stackrel{...}{\boxed{0}} \stackrel{...}{\boxed{0}} \stackrel{3}{\boxed{2}} \stackrel{2}{\boxed{0}} \stackrel{1}{\boxed{0}} \stackrel{0}{\boxed{15}}$$

اینجا باید بشینیم 259 تا خونه بکشیم و اینقدر فضا اشغال کنیم برای 3 تا عدد ؟
نه ما مهندسیم و اینکارارو نمیکنیم :sweat_smile:

به جاش چیکار کنیم پس ؟

به جای یه جدول تک بعدی یک جدول دوبعدی میکشیم :)

و توی سطر اول توان و سطر دوم ضریب رو قرار میدیم

$$
\begin{array}{|c|c|c|c|}
\hline
258 & 193 & 3   & 0  \\
\hline
7   & 4   & 2   & 15 \\
\hline
\end{array}
$$

حالا خیلی بهتر شد :)

## ماتریس پایین مثلثی

$$
\begin{bmatrix}
\textcolor{teal}{5} & 0 & 0 \\
\textcolor{teal}{1} & \textcolor{teal}{2} & 0 \\
\textcolor{teal}{3} & \textcolor{teal}{1} & \textcolor{teal}{7}
\end{bmatrix}
$$

همونطور که میبیند مقادیر در پایین سمت چپ ماتریس چیده شدن و باقی مقادیر صفر هستند.

در این صورت فقط ذخیره ستونی یا سطری مقادیر غیر صفر رو انجام میدیم و مقادیر صفر رو دیگه نمینویسیم

سطری:

$$ 5, 1, 2, 3, 1, 7 $$

ستونی:

$$ 5, 1, 3, 2, 1, 7 $$

## ماتریس بالا مثلثی

$$
\begin{bmatrix}
\textcolor{teal}{5} & \textcolor{teal}{1} & \textcolor{teal}{3} \\
0 & \textcolor{teal}{2} & \textcolor{teal}{1} \\
0 & 0 & \textcolor{teal}{7}
\end{bmatrix}
$$

این ماتریس هم مثل ماتریس قبلی هست، اما مقادیر غیر صفر بالا سمت راست قرار دارن، ذخیره ستونی و سطری برای این هم انجام میدیم:

سطری:

$$ 5, 1, 3, 2, 1, 7 $$

ستونی:

$$ 5, 1, 2, 3, 1, 7 $$

## جمع ماتریس ها

تنها نکته ای که این مبحث داره این هست که ماتریس هایی که میخوایم با هم جمع کنیم باید تعداد سطر و ستون یکسان داشته باشن.
و باقی کار دیگه یه جمع ساده اس.

$$
\begin{bmatrix} 
5 & 4 & 2 \\
1 & 6 & 5 \\
3 & 1 & 7
\end{bmatrix}
+
\begin{bmatrix} 
2 & 2 & 7 \\
5 & 5 & 6 \\
7 & 12 & 1
\end{bmatrix}
= 
\begin{bmatrix} 
7 & 6 & 9 \\
6 & 11 & 11 \\
10 & 13 & 8
\end{bmatrix}
$$

صرفا مقدار هر سطر و ستون در ماتریس هارو با هم جمع میکنیم و ماتریس جدیدمون به دست میاد.